input {
  # Beats input for log forwarding
  beats {
    port => 5044
    tags => ["beats"]
  }

  # TCP input for application logs
  tcp {
    port => 5000
    codec => json_lines
    tags => ["tcp"]
  }

  # UDP input for syslog
  udp {
    port => 5000
    codec => json_lines
    tags => ["udp"]
  }

  # File input for packet capture analysis
  file {
    path => "/pcap/*.pcap"
    start_position => "beginning"
    sincedb_path => "/dev/null"
    codec => plain
    tags => ["pcap"]
  }

  # HTTP input for web application events
  http {
    port => 8080
    codec => json
    tags => ["http", "webapp"]
  }
}

filter {
  # Parse timestamp fields
  date {
    match => [ "timestamp", "ISO8601", "yyyy-MM-dd HH:mm:ss" ]
    target => "@timestamp"
  }

  # Add cyberrange metadata
  mutate {
    add_field => { "cyberrange_environment" => "warfare_mode" }
    add_field => { "infrastructure_version" => "v2.0" }
  }

  # Handle different log types
  if "beats" in [tags] {
    # Process Filebeat logs
    if [fields][log_type] {
      mutate {
        add_field => { "log_category" => "%{[fields][log_type]}" }
      }
    }
  }

  if "pcap" in [tags] {
    # Parse PCAP data (simplified - would need tshark integration)
    grok {
      match => { "message" => "%{TIMESTAMP_ISO8601:pcap_timestamp} %{IP:src_ip} %{IP:dst_ip} %{WORD:protocol} %{NUMBER:src_port} %{NUMBER:dst_port}" }
    }
    
    # Classify traffic types
    if [src_ip] =~ "172\.16\.200\.150" or [dst_ip] =~ "172\.16\.200\.150" {
      mutate { add_field => { "traffic_type" => "target_vm" } }
    }
    
    if [src_ip] =~ "172\.16\.200\.151" or [dst_ip] =~ "172\.16\.200\.151" {
      mutate { add_field => { "traffic_type" => "attacker_vm" } }
    }

    # Detect common attack patterns
    if [dst_port] in ["22", "3389", "445", "135", "139"] {
      mutate { add_field => { "attack_category" => "lateral_movement" } }
    }

    if [dst_port] in ["80", "443", "8080", "8443"] {
      mutate { add_field => { "attack_category" => "web_attack" } }
    }

    if [protocol] == "ICMP" {
      mutate { add_field => { "attack_category" => "reconnaissance" } }
    }
  }

  if "webapp" in [tags] {
    # Parse web application events
    if [request_path] {
      # SQL injection detection
      if [request_path] =~ "(?i)(union|select|insert|update|delete|drop|exec|script)" {
        mutate { 
          add_field => { "security_event" => "sql_injection_attempt" }
          add_field => { "threat_level" => "high" }
        }
      }

      # XSS detection
      if [request_path] =~ "(?i)(<script|javascript:|onload=|onerror=)" {
        mutate { 
          add_field => { "security_event" => "xss_attempt" }
          add_field => { "threat_level" => "medium" }
        }
      }

      # Directory traversal detection
      if [request_path] =~ "\.\./" {
        mutate { 
          add_field => { "security_event" => "directory_traversal" }
          add_field => { "threat_level" => "high" }
        }
      }
    }

    # Parse user agent for reconnaissance
    if [user_agent] =~ "(?i)(nmap|masscan|zap|burp|sqlmap|dirb|gobuster)" {
      mutate { 
        add_field => { "security_event" => "scanning_tool_detected" }
        add_field => { "threat_level" => "medium" }
      }
    }
  }

  # GeoIP enrichment for external IPs (if any)
  if [src_ip] and [src_ip] !~ "^(10\.|172\.(1[6-9]|2[0-9]|3[01])\.|192\.168\.)" {
    geoip {
      source => "src_ip"
      target => "src_geoip"
    }
  }

  if [dst_ip] and [dst_ip] !~ "^(10\.|172\.(1[6-9]|2[0-9]|3[01])\.|192\.168\.)" {
    geoip {
      source => "dst_ip"
      target => "dst_geoip"
    }
  }

  # Calculate match scoring events
  if [security_event] {
    if [threat_level] == "high" {
      mutate { add_field => { "match_points" => "10" } }
    } else if [threat_level] == "medium" {
      mutate { add_field => { "match_points" => "5" } }
    } else {
      mutate { add_field => { "match_points" => "1" } }
    }

    # Add team identification based on source IP
    if [src_ip] =~ "172\.16\.200\.151" {
      mutate { add_field => { "team_id" => "red_team" } }
    }

    if [src_ip] =~ "172\.16\.200\.152" {
      mutate { add_field => { "team_id" => "blue_team" } }
    }
  }

  # Parse flag submissions from application logs
  if [message] =~ "FLAG_SUBMISSION" {
    grok {
      match => { "message" => "FLAG_SUBMISSION: user=%{WORD:user_id} lab=%{WORD:lab_id} flag=%{WORD:submitted_flag} result=%{WORD:flag_result}" }
    }

    if [flag_result] == "correct" {
      mutate { 
        add_field => { "event_type" => "flag_captured" }
        add_field => { "match_points" => "20" }
      }
    }
  }

  # Remove unnecessary fields to reduce storage
  mutate {
    remove_field => [ "host", "agent", "ecs", "log", "input" ]
  }
}

output {
  # Send to Elasticsearch
  elasticsearch {
    hosts => ["172.16.200.136:9200"]
    index => "cyberrange-logs-%{+YYYY.MM.dd}"
    template_name => "cyberrange"
    template => "/usr/share/logstash/templates/cyberrange-template.json"
    template_overwrite => true
  }

  # Send security events to a separate index
  if [security_event] {
    elasticsearch {
      hosts => ["172.16.200.136:9200"]
      index => "cyberrange-security-%{+YYYY.MM.dd}"
    }
  }

  # Send match scoring events to real-time index
  if [match_points] {
    elasticsearch {
      hosts => ["172.16.200.136:9200"]
      index => "cyberrange-scoring-%{+YYYY.MM.dd}"
    }

    # Also send to Redis for real-time updates
    redis {
      host => "172.16.200.140"
      port => 6379
      password => "cyberrange2024"
      data_type => "list"
      key => "cyberrange:scoring:events"
    }
  }

  # Debug output (remove in production)
  if [security_event] or [match_points] {
    stdout { 
      codec => rubydebug 
      tags => ["debug", "security"]
    }
  }
}
