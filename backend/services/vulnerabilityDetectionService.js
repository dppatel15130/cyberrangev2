const { ScoringEvent, Team, Match, User } = require('../models');
const { Op } = require('sequelize');
const { exec } = require('child_process');
const fs = require('fs').promises;
const path = require('path');
const scoringService = require('./scoringService');
const elkIntegrationService = require('./elkIntegrationService');

class VulnerabilityDetectionService {
  constructor() {
    this.activeScans = new Map();
    this.vulnerabilitySignatures = new Map();
    this.exploitDetectors = new Map();
    this.pointDecayMap = new Map(); // Track found vulnerabilities for decay
    
    // Initialize vulnerability signatures
    this.initializeVulnerabilitySignatures();
    
    // Configuration
    this.config = {
      scanInterval: parseInt(process.env.VULNERABILITY_SCAN_INTERVAL) || 30,
      enableAutoDetection: process.env.AUTO_FLAG_DETECTION === 'true',
      enablePointDecay: process.env.SCORING_DECAY_ENABLED === 'true',
      decayRate: parseFloat(process.env.POINT_DECAY_RATE) || 0.5,
      basePoints: parseInt(process.env.BASE_VULNERABILITY_POINTS) || 100,
      firstBloodBonus: parseInt(process.env.FIRST_BLOOD_BONUS) || 50
    };
  }

  // Initialize known vulnerability signatures for automatic detection
  initializeVulnerabilitySignatures() {
    // Windows 7 SP1 x64 Common Vulnerabilities
    this.vulnerabilitySignatures.set('ms17-010', {
      id: 'ms17-010',
      name: 'EternalBlue SMB Vulnerability',
      description: 'SMBv1 remote code execution vulnerability',
      basePoints: 150,
      category: 'network',
      ports: [445, 139],
      exploitPatterns: [
        'smb_exploit',
        'eternalblue',
        'ms17_010'
      ],
      logPatterns: [
        'SMB connection established',
        'NT_STATUS_ACCESS_DENIED',
        'pipe opened'
      ],
      networkSignatures: [
        { protocol: 'smb', pattern: 'negotiate_protocol_request' },
        { protocol: 'smb', pattern: 'tree_connect_andx' }
      ]
    });

    this.vulnerabilitySignatures.set('ms08-067', {
      id: 'ms08-067',
      name: 'Windows Server Service Vulnerability',
      description: 'RPC vulnerability in Windows Server service',
      basePoints: 120,
      category: 'network',
      ports: [445, 139],
      exploitPatterns: [
        'ms08_067',
        'netapi',
        'conficker'
      ],
      logPatterns: [
        'RPC endpoint request',
        'Server service accessed'
      ]
    });

    this.vulnerabilitySignatures.set('rdp-bluekeep', {
      id: 'rdp-bluekeep',
      name: 'BlueKeep RDP Vulnerability',
      description: 'CVE-2019-0708 Remote Desktop vulnerability',
      basePoints: 140,
      category: 'network',
      ports: [3389],
      exploitPatterns: [
        'bluekeep',
        'rdp_exploit',
        'cve_2019_0708'
      ],
      logPatterns: [
        'RDP connection established',
        'Terminal Services authentication'
      ]
    });

    this.vulnerabilitySignatures.set('weak-passwords', {
      id: 'weak-passwords',
      name: 'Weak Password Authentication',
      description: 'Successful authentication with weak credentials',
      basePoints: 80,
      category: 'authentication',
      ports: [22, 23, 21, 3389, 445],
      exploitPatterns: [
        'brute_force_success',
        'weak_credential',
        'dictionary_attack'
      ],
      logPatterns: [
        'Authentication successful',
        'Login successful',
        'User authenticated'
      ]
    });

    this.vulnerabilitySignatures.set('privilege-escalation', {
      id: 'privilege-escalation',
      name: 'Local Privilege Escalation',
      description: 'Escalation to administrator/system privileges',
      basePoints: 130,
      category: 'privilege',
      exploitPatterns: [
        'privilege_escalation',
        'admin_access',
        'system_shell'
      ],
      logPatterns: [
        'Administrator access granted',
        'Privilege escalation detected',
        'System level access'
      ]
    });

    this.vulnerabilitySignatures.set('web-exploitation', {
      id: 'web-exploitation',
      name: 'Web Application Exploitation',
      description: 'Successful web application attack',
      basePoints: 90,
      category: 'web',
      ports: [80, 443, 8080],
      exploitPatterns: [
        'sql_injection',
        'xss_attack',
        'directory_traversal',
        'command_injection'
      ],
      logPatterns: [
        'SQL injection detected',
        'Cross-site scripting',
        'Path traversal attempt',
        'Command execution'
      ]
    });

    this.vulnerabilitySignatures.set('lateral-movement', {
      id: 'lateral-movement',
      name: 'Lateral Movement',
      description: 'Movement between compromised systems',
      basePoints: 110,
      category: 'network',
      exploitPatterns: [
        'psexec',
        'wmi_execution',
        'pass_the_hash',
        'remote_execution'
      ],
      logPatterns: [
        'Remote command execution',
        'WMI process creation',
        'PSExec service'
      ]
    });

    this.vulnerabilitySignatures.set('data-exfiltration', {
      id: 'data-exfiltration',
      name: 'Data Exfiltration',
      description: 'Sensitive data extraction detected',
      basePoints: 160,
      category: 'data',
      exploitPatterns: [
        'data_copy',
        'file_transfer',
        'sensitive_access'
      ],
      logPatterns: [
        'Large file transfer',
        'Database access',
        'Sensitive file accessed'
      ]
    });
  }

  // Start vulnerability detection for a match
  async startDetectionForMatch(matchId) {
    try {
      const match = await Match.findByPk(matchId, {
        include: [{ model: Team, as: 'teams' }]
      });

      if (!match) {
        throw new Error('Match not found');
      }

      if (!this.config.enableAutoDetection) {
        console.log('Auto vulnerability detection is disabled');
        return false;
      }

      // Initialize point decay tracking for this match
      this.pointDecayMap.set(matchId, new Map());

      // Start monitoring
      const scanInterval = setInterval(async () => {
        try {
          await this.scanForVulnerabilities(matchId);
        } catch (error) {
          console.error('Vulnerability scan error:', error);
        }
      }, this.config.scanInterval * 1000);

      this.activeScans.set(matchId, {
        interval: scanInterval,
        match,
        teams: match.teams,
        startTime: new Date()
      });

      console.log(`Started vulnerability detection for match ${matchId} (${match.name})`);
      return true;
    } catch (error) {
      console.error('Error starting vulnerability detection:', error);
      throw error;
    }
  }

  // Stop vulnerability detection for a match
  async stopDetectionForMatch(matchId) {
    try {
      const scanData = this.activeScans.get(matchId);
      if (scanData) {
        clearInterval(scanData.interval);
        this.activeScans.delete(matchId);
        this.pointDecayMap.delete(matchId);
        console.log(`Stopped vulnerability detection for match ${matchId}`);
        return true;
      }
      return false;
    } catch (error) {
      console.error('Error stopping vulnerability detection:', error);
      throw error;
    }
  }

  // Main vulnerability scanning function
  async scanForVulnerabilities(matchId) {
    try {
      const scanData = this.activeScans.get(matchId);
      if (!scanData) return;

      // Multi-method detection approach
      const detectionResults = await Promise.all([
        this.detectFromNetworkLogs(matchId),
        this.detectFromSystemLogs(matchId),
        this.detectFromPacketCapture(matchId),
        this.detectFromProcessMonitoring(matchId),
        this.detectFromELKStack(matchId)
      ]);

      // Combine and process all detection results
      const allDetections = detectionResults.flat().filter(Boolean);
      
      for (const detection of allDetections) {
        await this.processVulnerabilityDetection(matchId, detection);
      }

    } catch (error) {
      console.error('Error during vulnerability scan:', error);
    }
  }

  // Detect vulnerabilities from network logs
  async detectFromNetworkLogs(matchId) {
    try {
      const logDir = process.env.LOG_DIRECTORY || '/var/log/cyberrange';
      const networkLogPath = path.join(logDir, 'network.log');
      
      // Check if network log exists
      try {
        await fs.access(networkLogPath);
      } catch {
        return []; // No network logs available
      }

      const logContent = await fs.readFile(networkLogPath, 'utf8');
      const recentLines = logContent.split('\n').slice(-1000); // Last 1000 lines
      
      const detections = [];

      for (const [vulnId, signature] of this.vulnerabilitySignatures) {
        for (const pattern of signature.logPatterns || []) {
          const matches = recentLines.filter(line => 
            line.toLowerCase().includes(pattern.toLowerCase()) &&
            this.isRecentLogEntry(line)
          );

          if (matches.length > 0) {
            detections.push({
              vulnerabilityId: vulnId,
              signature,
              sourceType: 'network_log',
              confidence: 0.7,
              evidence: {
                logMatches: matches.slice(0, 5),
                patternMatched: pattern
              },
              timestamp: new Date()
            });
          }
        }
      }

      return detections;
    } catch (error) {
      console.error('Network log detection error:', error);
      return [];
    }
  }

  // Detect vulnerabilities from system logs
  async detectFromSystemLogs(matchId) {
    try {
      const detections = [];
      
      // Check various system log locations
      const logPaths = [
        '/var/log/auth.log',
        '/var/log/syslog',
        '/var/log/messages',
        '/var/log/security'
      ];

      for (const logPath of logPaths) {
        try {
          const content = await fs.readFile(logPath, 'utf8');
          const lines = content.split('\n').slice(-500); // Recent lines
          
          const logDetections = this.analyzeLogLines(lines, 'system_log');
          detections.push(...logDetections);
        } catch {
          // Log file doesn't exist or can't be read
          continue;
        }
      }

      return detections;
    } catch (error) {
      console.error('System log detection error:', error);
      return [];
    }
  }

  // Analyze log lines for vulnerability patterns
  analyzeLogLines(lines, sourceType) {
    const detections = [];
    
    for (const line of lines) {
      if (!this.isRecentLogEntry(line)) continue;
      
      for (const [vulnId, signature] of this.vulnerabilitySignatures) {
        for (const pattern of signature.exploitPatterns || []) {
          if (line.toLowerCase().includes(pattern.toLowerCase())) {
            detections.push({
              vulnerabilityId: vulnId,
              signature,
              sourceType,
              confidence: 0.6,
              evidence: {
                logLine: line,
                patternMatched: pattern
              },
              timestamp: new Date()
            });
          }
        }
      }
    }
    
    return detections;
  }

  // Detect vulnerabilities from packet capture
  async detectFromPacketCapture(matchId) {
    try {
      const pcapDir = process.env.PCAP_DIRECTORY || '/opt/cyberrange/pcap-data';
      
      try {
        const files = await fs.readdir(pcapDir);
        const recentPcaps = files
          .filter(f => f.endsWith('.pcap'))
          .map(f => ({
            name: f,
            path: path.join(pcapDir, f)
          }))
          .slice(-3); // Process latest 3 files

        const detections = [];
        
        for (const pcap of recentPcaps) {
          const pcapDetections = await this.analyzePcapForVulnerabilities(pcap);
          detections.push(...pcapDetections);
        }

        return detections;
      } catch {
        return []; // No PCAP directory or files
      }
    } catch (error) {
      console.error('Packet capture detection error:', error);
      return [];
    }
  }

  // Analyze PCAP file for vulnerability exploitation
  async analyzePcapForVulnerabilities(pcapInfo) {
    return new Promise((resolve) => {
      const detections = [];
      
      // Use tshark to analyze PCAP if available
      const tsharkCmd = `tshark -r "${pcapInfo.path}" -T json -e ip.src -e ip.dst -e tcp.dstport -e frame.protocols -c 200`;
      
      exec(tsharkCmd, { timeout: 10000 }, (error, stdout) => {
        if (error) {
          resolve([]); // tshark not available or error
          return;
        }

        try {
          const packets = JSON.parse(`[${stdout.trim().replace(/}\n{/g, '},{')}]`);
          
          for (const [vulnId, signature] of this.vulnerabilitySignatures) {
            const portMatches = packets.filter(p => 
              signature.ports && signature.ports.includes(parseInt(p['tcp.dstport']))
            );

            if (portMatches.length > 10) { // Significant activity on vulnerable port
              detections.push({
                vulnerabilityId: vulnId,
                signature,
                sourceType: 'packet_capture',
                confidence: 0.8,
                evidence: {
                  packetCount: portMatches.length,
                  targetPorts: signature.ports,
                  pcapFile: pcapInfo.name
                },
                timestamp: new Date()
              });
            }
          }

          resolve(detections);
        } catch {
          resolve([]);
        }
      });
    });
  }

  // Detect from process monitoring
  async detectFromProcessMonitoring(matchId) {
    try {
      const detections = [];
      
      // Monitor running processes for exploitation tools
      const processCmd = 'ps aux | grep -E "(msfconsole|metasploit|nmap|sqlmap|dirb|gobuster|hydra|john|hashcat)"';
      
      return new Promise((resolve) => {
        exec(processCmd, (error, stdout) => {
          if (error) {
            resolve([]);
            return;
          }

          const processes = stdout.split('\n').filter(line => 
            line && !line.includes('grep')
          );

          for (const process of processes) {
            // Detect Metasploit usage
            if (process.includes('msfconsole') || process.includes('metasploit')) {
              detections.push({
                vulnerabilityId: 'metasploit-usage',
                signature: {
                  id: 'metasploit-usage',
                  name: 'Metasploit Framework Usage',
                  basePoints: 50,
                  category: 'tool'
                },
                sourceType: 'process_monitor',
                confidence: 0.9,
                evidence: { process },
                timestamp: new Date()
              });
            }

            // Detect credential cracking
            if (process.includes('john') || process.includes('hashcat') || process.includes('hydra')) {
              detections.push({
                vulnerabilityId: 'credential-cracking',
                signature: {
                  id: 'credential-cracking',
                  name: 'Credential Cracking Tool',
                  basePoints: 60,
                  category: 'tool'
                },
                sourceType: 'process_monitor',
                confidence: 0.8,
                evidence: { process },
                timestamp: new Date()
              });
            }
          }

          resolve(detections);
        });
      });
    } catch (error) {
      console.error('Process monitoring error:', error);
      return [];
    }
  }

  // Detect from ELK Stack
  async detectFromELKStack(matchId) {
    try {
      if (!process.env.ENABLE_ELK_INTEGRATION || process.env.ENABLE_ELK_INTEGRATION !== 'true') {
        return [];
      }

      const elasticsearchUrl = process.env.ELASTICSEARCH_URL || 'http://172.16.200.136:9200';
      
      // Query Elasticsearch for recent security events
      const query = {
        query: {
          bool: {
            must: [
              { range: { '@timestamp': { gte: 'now-5m' } } },
              { terms: { 'event.category': ['attack', 'exploitation', 'vulnerability'] } }
            ]
          }
        },
        size: 50
      };

      const { exec } = require('child_process');
      
      return new Promise((resolve) => {
        const curlCmd = `curl -s -X POST "${elasticsearchUrl}/cyberrange-security-*/_search" -H "Content-Type: application/json" -d '${JSON.stringify(query)}'`;
        
        exec(curlCmd, (error, stdout) => {
          if (error) {
            resolve([]);
            return;
          }

          try {
            const response = JSON.parse(stdout);
            const hits = response.hits?.hits || [];
            
            const detections = hits.map(hit => ({
              vulnerabilityId: hit._source.vulnerability_id || 'elk-detected',
              signature: {
                id: hit._source.vulnerability_id || 'elk-detected',
                name: hit._source.event_name || 'ELK Stack Detection',
                basePoints: hit._source.severity_score || 75,
                category: 'elk'
              },
              sourceType: 'elk_stack',
              confidence: hit._source.confidence || 0.8,
              evidence: hit._source,
              timestamp: new Date(hit._source['@timestamp'])
            }));

            resolve(detections);
          } catch {
            resolve([]);
          }
        });
      });
    } catch (error) {
      console.error('ELK Stack detection error:', error);
      return [];
    }
  }

  // Process detected vulnerability and award points
  async processVulnerabilityDetection(matchId, detection) {
    try {
      const scanData = this.activeScans.get(matchId);
      if (!scanData) return;

      // Determine which team performed the exploitation
      const teamId = await this.identifyExploitingTeam(matchId, detection);
      if (!teamId) {
        console.log('Could not identify exploiting team for detection:', detection.vulnerabilityId);
        return;
      }

      // Calculate points with decay
      const points = this.calculatePointsWithDecay(matchId, detection);
      
      if (points <= 0) {
        console.log(`No points awarded for ${detection.vulnerabilityId} - already found by multiple teams`);
        return;
      }

      // Create scoring event
      const scoringEvent = await scoringService.createScoringEvent(matchId, teamId, {
        eventType: 'vulnerability_exploit',
        eventSubtype: detection.signature.category,
        basePoints: detection.signature.basePoints,
        finalPoints: points,
        confidence: detection.confidence,
        description: `${detection.signature.name}: ${detection.signature.description}`,
        sourceType: detection.sourceType,
        vulnerabilityId: detection.vulnerabilityId,
        evidence: detection.evidence,
        timestamp: detection.timestamp
      });

      console.log(`🎯 Vulnerability detected and scored: ${detection.signature.name} (+${points} points for Team ${teamId})`);
      
      // Log to ELK Stack if available
      await elkIntegrationService.logSecurityEvent({
        category: 'vulnerability_exploit',
        name: detection.signature.name,
        vulnerabilityId: detection.vulnerabilityId,
        severity: detection.signature.basePoints,
        confidence: detection.confidence,
        matchId,
        teamId,
        detectionMethod: detection.sourceType,
        evidence: detection.evidence
      });
      
      // Update point decay tracking
      this.updatePointDecayTracking(matchId, detection.vulnerabilityId, teamId);

      return scoringEvent;
    } catch (error) {
      console.error('Error processing vulnerability detection:', error);
    }
  }

  // Identify which team performed the exploitation
  async identifyExploitingTeam(matchId, detection) {
    try {
      const scanData = this.activeScans.get(matchId);
      if (!scanData) return null;

      // Try to extract IP addresses from evidence
      const sourceIPs = this.extractSourceIPs(detection.evidence);
      
      for (const ip of sourceIPs) {
        for (const team of scanData.teams) {
          if (this.isIPInTeamRange(ip, team.id)) {
            return team.id;
          }
        }
      }

      // Fallback: If no IP match, assign to first active team
      // In a real environment, this would be more sophisticated
      return scanData.teams[0]?.id || null;
    } catch (error) {
      console.error('Error identifying exploiting team:', error);
      return null;
    }
  }

  // Extract source IP addresses from detection evidence
  extractSourceIPs(evidence) {
    const ips = [];
    
    if (evidence.networkFlow) {
      ips.push(evidence.networkFlow.srcIp);
    }
    
    if (evidence.logLine) {
      const ipRegex = /\b(?:[0-9]{1,3}\.){3}[0-9]{1,3}\b/g;
      const matches = evidence.logLine.match(ipRegex);
      if (matches) ips.push(...matches);
    }

    if (evidence.logMatches) {
      for (const line of evidence.logMatches) {
        const ipRegex = /\b(?:[0-9]{1,3}\.){3}[0-9]{1,3}\b/g;
        const matches = line.match(ipRegex);
        if (matches) ips.push(...matches);
      }
    }

    return [...new Set(ips)]; // Remove duplicates
  }

  // Check if IP is in team's assigned range
  isIPInTeamRange(ip, teamId) {
    // Simple implementation based on team subnets
    const teamSubnetBase = process.env.TEAM_SUBNET_BASE || '172.16.200';
    const teamRange = `${teamSubnetBase}.${150 + (teamId * 10)}`;
    
    return ip.startsWith(teamRange);
  }

  // Calculate points with decay system
  calculatePointsWithDecay(matchId, detection) {
    const decayMap = this.pointDecayMap.get(matchId);
    if (!decayMap) return detection.signature.basePoints;

    const vulnDecayData = decayMap.get(detection.vulnerabilityId) || {
      findCount: 0,
      firstTeam: null,
      teamsFound: new Set()
    };

    let points = detection.signature.basePoints;

    // First blood bonus
    if (vulnDecayData.findCount === 0) {
      points += this.config.firstBloodBonus;
      vulnDecayData.firstTeam = detection.teamId;
    } else if (this.config.enablePointDecay) {
      // Apply decay based on how many teams have found it
      const decayFactor = Math.pow(this.config.decayRate, vulnDecayData.findCount);
      points = Math.floor(points * decayFactor);
    }

    // Minimum points (so it's always worth something)
    points = Math.max(points, 10);

    return points;
  }

  // Update point decay tracking
  updatePointDecayTracking(matchId, vulnerabilityId, teamId) {
    const decayMap = this.pointDecayMap.get(matchId);
    if (!decayMap) return;

    const vulnDecayData = decayMap.get(vulnerabilityId) || {
      findCount: 0,
      firstTeam: null,
      teamsFound: new Set()
    };

    if (!vulnDecayData.teamsFound.has(teamId)) {
      vulnDecayData.findCount++;
      vulnDecayData.teamsFound.add(teamId);
      decayMap.set(vulnerabilityId, vulnDecayData);
    }
  }

  // Check if log entry is recent (within scan interval)
  isRecentLogEntry(logLine) {
    try {
      // Extract timestamp from log line (various formats)
      const timestampRegex = /(\d{4}-\d{2}-\d{2}[T ]\d{2}:\d{2}:\d{2})/;
      const match = logLine.match(timestampRegex);
      
      if (match) {
        const logTime = new Date(match[1]);
        const now = new Date();
        const diffMinutes = (now - logTime) / (1000 * 60);
        return diffMinutes <= (this.config.scanInterval / 60) * 2; // Within 2 scan intervals
      }
      
      return true; // If no timestamp found, assume recent
    } catch {
      return true;
    }
  }

  // Get vulnerability detection statistics
  async getDetectionStats(matchId) {
    try {
      const scanData = this.activeScans.get(matchId);
      if (!scanData) return null;

      const decayMap = this.pointDecayMap.get(matchId) || new Map();
      const stats = {
        matchId,
        scanActive: true,
        startTime: scanData.startTime,
        vulnerabilitiesFound: decayMap.size,
        totalDetections: 0,
        uniqueVulnerabilities: Array.from(decayMap.keys()),
        teamStats: {}
      };

      // Calculate team-specific stats
      for (const [vulnId, vulnData] of decayMap) {
        stats.totalDetections += vulnData.findCount;
        
        for (const teamId of vulnData.teamsFound) {
          if (!stats.teamStats[teamId]) {
            stats.teamStats[teamId] = {
              vulnerabilitiesFound: 0,
              firstBloodCount: 0
            };
          }
          
          stats.teamStats[teamId].vulnerabilitiesFound++;
          if (vulnData.firstTeam === teamId) {
            stats.teamStats[teamId].firstBloodCount++;
          }
        }
      }

      return stats;
    } catch (error) {
      console.error('Error getting detection stats:', error);
      return null;
    }
  }

  // Manual vulnerability confirmation (admin feature)
  async confirmVulnerability(matchId, teamId, vulnerabilityId, adminId) {
    try {
      const signature = this.vulnerabilitySignatures.get(vulnerabilityId);
      if (!signature) {
        throw new Error('Unknown vulnerability ID');
      }

      const points = this.calculatePointsWithDecay(matchId, { signature, vulnerabilityId });
      
      const scoringEvent = await scoringService.createScoringEvent(matchId, teamId, {
        eventType: 'vulnerability_exploit',
        eventSubtype: 'manual_confirmation',
        basePoints: signature.basePoints,
        finalPoints: points,
        confidence: 1.0,
        description: `Manual confirmation: ${signature.name}`,
        sourceType: 'admin_manual',
        vulnerabilityId,
        adminId,
        evidence: {
          manualConfirmation: true,
          confirmedBy: adminId
        }
      });

      this.updatePointDecayTracking(matchId, vulnerabilityId, teamId);

      console.log(`✅ Manual vulnerability confirmation: ${signature.name} (+${points} points for Team ${teamId})`);
      return scoringEvent;
    } catch (error) {
      console.error('Error confirming vulnerability:', error);
      throw error;
    }
  }

  // Get available vulnerabilities list
  getAvailableVulnerabilities() {
    return Array.from(this.vulnerabilitySignatures.values()).map(sig => ({
      id: sig.id,
      name: sig.name,
      description: sig.description,
      basePoints: sig.basePoints,
      category: sig.category,
      ports: sig.ports
    }));
  }
}

module.exports = new VulnerabilityDetectionService();
