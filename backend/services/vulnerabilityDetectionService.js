const { Match, Team, Flag, ScoringEvent, VM } = require('../models');
const axios = require('axios');
const { Op } = require('sequelize');

class VulnerabilityDetectionService {
  constructor() {
    this.activeMatches = new Map();
    this.detectionIntervals = new Map();
  }

  /**
   * Start vulnerability detection for a match
   */
  async startDetection(matchId) {
    try {
      const match = await Match.findByPk(matchId, {
        include: [
          {
            model: Team,
            as: 'teams',
            include: [{ model: VM, as: 'vms' }]
          },
          {
            model: Flag,
            as: 'flags',
            where: { isActive: true }
          }
        ]
      });

      if (!match || match.status !== 'active') {
        console.log(`Match ${matchId} is not active, skipping detection`);
        return;
      }

      console.log(`Starting vulnerability detection for match ${matchId}`);

      // Store match data
      this.activeMatches.set(matchId, match);

      // Start periodic detection
      const interval = setInterval(async () => {
        await this.performDetection(matchId);
      }, 30000); // Check every 30 seconds

      this.detectionIntervals.set(matchId, interval);

      // Initial detection
      await this.performDetection(matchId);

    } catch (error) {
      console.error(`Error starting vulnerability detection for match ${matchId}:`, error);
    }
  }

  /**
   * Stop vulnerability detection for a match
   */
  stopDetection(matchId) {
    const interval = this.detectionIntervals.get(matchId);
    if (interval) {
      clearInterval(interval);
      this.detectionIntervals.delete(matchId);
      this.activeMatches.delete(matchId);
      console.log(`Stopped vulnerability detection for match ${matchId}`);
    }
  }

  /**
   * Perform vulnerability detection
   */
  async performDetection(matchId) {
    try {
      const match = this.activeMatches.get(matchId);
      if (!match) return;

      console.log(`Performing vulnerability detection for match ${matchId}`);

      // Get target VM
      const targetVM = await VM.findOne({
        where: { 
          id: match.networkConfig?.targetVM,
          isTarget: true
        }
      });

      if (!targetVM) {
        console.log(`Target VM not found for match ${matchId}`);
        return;
      }

      // Check each vulnerability
      for (const flag of match.flags) {
        if (flag.capturedBy) continue; // Already captured

        const isVulnerable = await this.checkVulnerability(targetVM, flag);
        
        if (isVulnerable) {
          await this.awardPoints(match, flag);
        }
      }

    } catch (error) {
      console.error(`Error in vulnerability detection for match ${matchId}:`, error);
    }
  }

  /**
   * Check if a specific vulnerability exists
   */
  async checkVulnerability(targetVM, flag) {
    try {
      const targetIP = targetVM.ipAddress;
      
      switch (flag.vulnerability) {
        case 'ms17-010':
          return await this.checkMS17010(targetIP);
        
        case 'smb_v1':
          return await this.checkSMBv1(targetIP);
        
        case 'open_ports':
          return await this.checkOpenPorts(targetIP);
        
        case 'weak_passwords':
          return await this.checkWeakPasswords(targetIP);
        
        case 'rdp_access':
          return await this.checkRDPAccess(targetIP);
        
        default:
          return false;
      }
    } catch (error) {
      console.error(`Error checking vulnerability ${flag.vulnerability}:`, error);
      return false;
    }
  }

  /**
   * Check MS17-010 vulnerability
   */
  async checkMS17010(targetIP) {
    try {
      // Use nmap to check for MS17-010
      const { exec } = require('child_process');
      
      return new Promise((resolve) => {
        exec(`nmap -p 445 --script smb-vuln-ms17-010 ${targetIP}`, (error, stdout, stderr) => {
          if (error) {
            console.error(`Error checking MS17-010: ${error}`);
            resolve(false);
            return;
          }
          
          // Check if vulnerability is detected
          const isVulnerable = stdout.includes('VULNERABLE') || 
                             stdout.includes('ms17-010') ||
                             stdout.includes('EternalBlue');
          
          console.log(`MS17-010 check for ${targetIP}: ${isVulnerable ? 'VULNERABLE' : 'SAFE'}`);
          resolve(isVulnerable);
        });
      });
    } catch (error) {
      console.error(`Error in MS17-010 check:`, error);
      return false;
    }
  }

  /**
   * Check SMB version 1
   */
  async checkSMBv1(targetIP) {
    try {
      const { exec } = require('child_process');
      
      return new Promise((resolve) => {
        exec(`nmap -p 445 --script smb-protocols ${targetIP}`, (error, stdout, stderr) => {
          if (error) {
            console.error(`Error checking SMBv1: ${error}`);
            resolve(false);
            return;
          }
          
          // Check if SMBv1 is enabled
          const hasSMBv1 = stdout.includes('SMBv1') || 
                          stdout.includes('NT LM 0.12') ||
                          stdout.includes('CIFS');
          
          console.log(`SMBv1 check for ${targetIP}: ${hasSMBv1 ? 'ENABLED' : 'DISABLED'}`);
          resolve(hasSMBv1);
        });
      });
    } catch (error) {
      console.error(`Error in SMBv1 check:`, error);
      return false;
    }
  }

  /**
   * Check open ports
   */
  async checkOpenPorts(targetIP) {
    try {
      const { exec } = require('child_process');
      
      return new Promise((resolve) => {
        exec(`nmap -sS -p- --min-rate=1000 ${targetIP}`, (error, stdout, stderr) => {
          if (error) {
            console.error(`Error checking open ports: ${error}`);
            resolve(false);
            return;
          }
          
          // Check for expected open ports
          const openPorts = stdout.match(/(\d+)\/tcp\s+open/g);
          const expectedPorts = ['21/tcp', '22/tcp', '80/tcp', '445/tcp', '3389/tcp'];
          
          const hasExpectedPorts = expectedPorts.every(port => 
            openPorts && openPorts.some(openPort => openPort.includes(port.split('/')[0]))
          );
          
          console.log(`Open ports check for ${targetIP}: ${hasExpectedPorts ? 'EXPECTED PORTS OPEN' : 'NOT ALL PORTS OPEN'}`);
          resolve(hasExpectedPorts);
        });
      });
    } catch (error) {
      console.error(`Error in open ports check:`, error);
      return false;
    }
  }

  /**
   * Check weak passwords
   */
  async checkWeakPasswords(targetIP) {
    try {
      const { exec } = require('child_process');
      
      return new Promise((resolve) => {
        // Check for common weak passwords
        exec(`hydra -l admin -P /usr/share/wordlists/rockyou.txt ${targetIP} smb -t 1 -f`, (error, stdout, stderr) => {
          if (error) {
            console.error(`Error checking weak passwords: ${error}`);
            resolve(false);
            return;
          }
          
          // Check if login was successful
          const loginSuccess = stdout.includes('login:') && 
                             (stdout.includes('password:') || stdout.includes('1 valid password'));
          
          console.log(`Weak password check for ${targetIP}: ${loginSuccess ? 'WEAK PASSWORD FOUND' : 'NO WEAK PASSWORD'}`);
          resolve(loginSuccess);
        });
      });
    } catch (error) {
      console.error(`Error in weak password check:`, error);
      return false;
    }
  }

  /**
   * Check RDP access
   */
  async checkRDPAccess(targetIP) {
    try {
      const { exec } = require('child_process');
      
      return new Promise((resolve) => {
        exec(`nmap -p 3389 --script rdp-enum-encryption ${targetIP}`, (error, stdout, stderr) => {
          if (error) {
            console.error(`Error checking RDP access: ${error}`);
            resolve(false);
            return;
          }
          
          // Check if RDP is accessible
          const rdpAccessible = stdout.includes('3389/tcp') && 
                               (stdout.includes('open') || stdout.includes('filtered'));
          
          console.log(`RDP access check for ${targetIP}: ${rdpAccessible ? 'ACCESSIBLE' : 'NOT ACCESSIBLE'}`);
          resolve(rdpAccessible);
        });
      });
    } catch (error) {
      console.error(`Error in RDP access check:`, error);
      return false;
    }
  }

  /**
   * Award points to teams for vulnerability discovery
   */
  async awardPoints(match, flag) {
    try {
      // Find the team that discovered the vulnerability first
      // For now, award to the first team (you can implement more sophisticated logic)
      const teams = await match.getTeams();
      
      if (teams.length === 0) {
        console.log('No teams found for match');
        return;
      }

      const winningTeam = teams[0]; // First team gets the points
      
      // Check if flag was already captured
      if (flag.capturedBy) {
        console.log(`Flag ${flag.name} already captured by team ${flag.capturedBy}`);
        return;
      }

      // Award points
      const points = flag.points;
      await winningTeam.increment('currentPoints', { by: points });
      
      // Mark flag as captured
      await flag.update({
        capturedBy: winningTeam.id,
        capturedAt: new Date()
      });

      // Create scoring event
      await ScoringEvent.create({
        matchId: match.id,
        teamId: winningTeam.id,
        eventType: 'vulnerability_exploit',
        points: points,
        description: `Discovered vulnerability: ${flag.name}`,
        metadata: {
          flagId: flag.id,
          vulnerability: flag.vulnerability,
          targetIP: match.networkConfig?.targetVM
        }
      });

      console.log(`âœ… Awarded ${points} points to ${winningTeam.name} for ${flag.name}`);

      // Send real-time update via WebSocket (if implemented)
      this.sendRealTimeUpdate(match.id, {
        type: 'vulnerability_discovered',
        team: winningTeam.name,
        flag: flag.name,
        points: points
      });

    } catch (error) {
      console.error('Error awarding points:', error);
    }
  }

  /**
   * Send real-time updates
   */
  sendRealTimeUpdate(matchId, data) {
    // This would integrate with your WebSocket service
    console.log(`Real-time update for match ${matchId}:`, data);
  }

  /**
   * Get detection status for a match
   */
  getDetectionStatus(matchId) {
    return {
      isActive: this.activeMatches.has(matchId),
      hasInterval: this.detectionIntervals.has(matchId)
    };
  }

  /**
   * Stop all detection
   */
  stopAllDetection() {
    for (const [matchId] of this.detectionIntervals) {
      this.stopDetection(matchId);
    }
  }
}

module.exports = new VulnerabilityDetectionService();
